<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Pole-Zero plot</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: system-ui, sans-serif;
    }

    h4 {
      font-weight: normal;
      text-align: center;
    }

    .grid {
      display: grid;
      grid-template-columns: max-content max-content max-content;
    }

    .unit-circle {
      fill: #f6f6f6;
      stroke: #ccc;
      stroke-width: 1px;
    }

    .shaded {
      fill: #f6f6f6;
      stroke: none;
    }

    .axis path,
    .axis line {
      fill: none;
      stroke: #ccc;
    }

    .axis > text {
      fill: #333;
      font-size: 12px;
      cursor: default;
    }

    .zero circle, .conjugate-zero circle {
      stroke: darkslateblue;
      stroke-width: 2px;
      fill: transparent;
    }

    .pole line, .conjugate-pole line {
      stroke: darkslateblue;
      stroke-width: 2px;
    }

    .selected line, .selected circle {
      stroke-width: 2px;
    }

    .magnitude {
      stroke: darkorange;
      stroke-width: 2px;
      fill: none;
    }

    .magnitude-area {
      fill: orange;
      fill-opacity: 0.2;
      stroke-width: 0;
    }

    .phase {
      fill: none;
      stroke: darkorchid;
      stroke-width: 2px;
    }

    .sine {
      fill: none;
      stroke: deeppink;
      stroke-width: 2px;
    }

    .cosine {
      fill: none;
      stroke: dodgerblue;
      stroke-width: 2px;
    }

  </style>
</head>
<body>
  <div class="grid">
    <div>
      <h4>Pole-Zero</h4>
      <svg id="pole-zero"></svg>
    </div>
    <div>
      <h4>Magnitude (dB)</h4>
      <svg id="magnitude"></svg>
    </div>
    <div>
      <h4>Phase</h4>
      <svg id="phase"></svg>
    </div>
  </div>
  <svg id="timeplot"></svg>
  <script>

    const uniqueGenerator = (prefix = '') => {
      let number = 1
      return () => {
        number += 1
        return `${prefix}${number}`
      }
    }

    const unique = uniqueGenerator('polezero-')

    const pole = (x, y, strength) => ({
      x, y, strength, type: 'pole', key: unique(),
    })

    const zero = (x, y, strength) => ({
      x, y, strength, type: 'zero', key: unique(),
    })

    const distance = (x1, y1, x2=0, y2=0) => Math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2))

    const angle = (x, y) => Math.atan2(y, x)

    const snap = (value, to=0, delta=0.1) => Math.abs(value - to) > delta ? value : to

    const limitToUnitCircle = (x, y) => {
      const amp = x*x + y*y
      if (amp >= 1) {
        const ang = Math.atan2(y, x)
        x = Math.cos(ang)
        y = Math.sin(ang)
      }
      return [x, y]
    }

    const decibel = (value) => 20 * Math.log(value) / Math.LN10

    const magnitude = (freq, zeros, poles) => {
      // e^j⍵
      const x = Math.cos(freq)
      const y = Math.sin(freq)
      let numerator = 1
      let denominator = 1

      // |e^j⍵ - zero|
      for (let z of zeros) {
        numerator *= Math.pow(distance(x, y, z.x, z.y), z.strength)
        numerator *= Math.pow(distance(x, y, z.x, -z.y), z.strength) // conjugate
      }

      // |e^j⍵ - pole|
      for (let p of poles) {
        denominator *= Math.pow(distance(x, y, p.x, p.y), p.strength)
        denominator *= Math.pow(distance(x, y, p.x, -p.y), p.strength) // conjugate
      }

      let mag = numerator / denominator
      if (isNaN(mag)) mag = 1 // 0/0

      return [freq, decibel(mag)]
    }

    const unwrap = (p) => {
      while (p > Math.PI) p -= 2*Math.PI
      while (p < -Math.PI) p += 2*Math.PI
      return p
    }

    const phase = (freq, zeros, poles) => {
      // e^j⍵
      const x = Math.cos(freq)
      const y = Math.sin(freq)
      let ph = 0

      // ∠ (e^j⍵, pole)
      for (let p of poles) {
        ph += Math.atan2(x-p.x, y-p.y) * p.strength
        ph += Math.atan2(x-p.x, y+p.y) * p.strength // conjugate
      }

      // ∠ (e^j⍵, zero)
      for (let z of zeros) {
        ph -= Math.atan2(x-z.x, y-z.y) * z.strength
        ph -= Math.atan2(x-z.x, y+z.y) * z.strength // conjugate
      }
      return [freq, unwrap(ph)]
    }

    // const analysis = (range, signal) => (freq) => {
    //   const sine = sinusoid(freq)
    //   const cosine = sinusoid(freq, Math.PI/2)
    //   const complex = [0, 0]
    //   for (const t of range) {
    //     complex[0] += signal(t) * cosine(t),
    //     complex[1] -= signal(t) * sine(t)
    //   }
    //   return magnitude(complex)
    // }


    // f(t) cos(2pist) dt
    //-  f(t) sin(2pist) dt

    // f(t)  e ^(-i2pist) dt


    const frequencyResponse = (zeros, poles) => {

    }

    const impulseResponse = (time, zeros, poles, frequencies) => {
      let result = [0, 0]

      // const A = distance(z[0], z[1])
      // const w = angle(z[0], z[1])

      for (const f of frequencies) {
        // freq respose for f is on the unit circle at angle f, it's a complex number

      }

      // for all frequencies apply inverse fourier

      // for (let z of zeros) {
      //   const A = distance(z.x, z.y)
      //   const w = angle(z.x, z.y)
      //   const amp = Math.pow(A, time)
      //   re -= amp * Math.cos(w * time)
      //   im -= amp * Math.sin(w * time)
      // }

      for (let p of poles) {
        const [re, im] = response(polar(p), time)
        result[0] += re
        result[1] += im

        const p1 = conjugate(p)
        const [re1, im1] = response(polar(p1), time)
        result[0] += re1
        result[1] += im1
      }

      return result
    }

    // pole in polar form
    const response = ({r, w}, time) => {
      const amp = Math.pow(r, time)
      const re = amp * Math.cos(w * time)
      const im = amp * Math.sin(w * time)
      return [re, im]
    }

    const conjugate = ({x, y}) => ({x, y: -y})

    const polar = ({x, y}) => {
      const r = distance(x, y)
      const w = angle(x, y)
      return {r, w}
    }

    const createClippingRect = (svg, id, width, height) => {
      let defs = svg.select('defs')
      if (defs.size() == 0) defs = svg.append('defs')
      defs.append('clipPath').attr('id', id)
        .append('rect')
        .attr('width', width)
        .attr('height', height)
    }

    const drawZero = (selection) =>{
      selection.append('circle').attr('r', 7)
      selection.append('text')
        .classed('strength', true)
        .attr('x', 10)
    }

    const drawPole = (selection) => {
      selection.append('line')
        .attr('x1', -6)
        .attr('y1', -6)
        .attr('x2', 6)
        .attr('y2', 6)
      selection.append('line')
        .attr('x1', -6)
        .attr('y1', 6)
        .attr('x2', 6)
        .attr('y2', -6)
      selection.append('text')
        .classed('strength', true)
        .attr('x', 10)
      // drag target
      selection.append('rect')
        .attr('x', -5)
        .attr('y', -6)
        .attr('width', 12)
        .attr('height', 12)
        .style('fill', 'transparent')
    }

    class Plot {
      constructor({svgSelector, xdomain, ydomain, width, height, margin}) {
        this.width = width
        this.height = height
        this.margin = margin
        this.x = d3.scaleLinear().domain(xdomain).range([margin, width - margin])
        this.y = d3.scaleLinear().domain(ydomain).range([margin, height - margin])
        this.svg = d3.select(svgSelector)
          .attr('width', width)
          .attr('height', height)
      }
    }

    class PoleZeroPlot extends Plot {
      constructor({onDrag, onSelect, selected, selectedZero, ...args}) {
        super(args)
        this.drawLayout()
        this.origin = [this.x.invert(0), this.y.invert(0)]

        const self = this // workaround for d3 using `this` as target element :/

        this.drag = d3.drag()
          .on('start', function (e) {
            e.sourceEvent.preventDefault()
            d3.select(this).raise()
          // d3.select(e.sourceEvent.target).classed('drag', true).attr('r', 7)
          })
          .on('drag', function (e) {
            const targetEl = d3.select(this)
            const datum = targetEl.datum()
            const newDatum = {...datum}
            let {dx, dy} = e

            const x = snap(self.x(datum.x) + dx, self.origin[0], 3)
            const y = snap(self.y(datum.y) + dy, self.origin[1], 3)

            newDatum.x = self.x.invert(x)
            newDatum.y = self.y.invert(y)

            targetEl
              .attr('transform', `translate(${[x, self.y(newDatum.y)]})`)
              .datum(newDatum)

            let conjugate = ''

            if (targetEl.classed('zero')) conjugate = '.conjugate-zero'
            else if (targetEl.classed('conjugate-zero')) conjugate = '.zero'
            else if (targetEl.classed('pole')) conjugate = '.conjugate-pole'
            else if (targetEl.classed('conjugate-pole')) conjugate = '.pole'

            self.svg.selectAll(conjugate)
              .filter((d) => d.key === datum.key)
              .datum({...newDatum, y: -newDatum.y})
              .attr('transform', `translate(${[x, self.y(-newDatum.y)]})`)

            onDrag(newDatum)
          })
          .on('end', (e) => {
            // d3.select(e.sourceEvent.target).classed('drag', false).attr('r', 5)
          })


        // this.onSelect = onSelect
        // this.selected = selected
      }

      drawPolesZeros(data) {
        this.svg.selectAll('.zero')
          .data(data.filter(d => d.type === 'zero'))
          .join('g')
            .classed('zero', true)
            // .classed('selected', (d, i) => i == this.selected)
            .call(drawZero)
            .call(this.drag)
            .attr('transform', d => `translate(${[this.x(d.x), this.y(d.y)]})`)
            // .on('click', (d, i) => this.onSelect(d, i))
            .select('.strength')
              .text(d => d[2])
              .attr('visibility', d => d.strength > 1 ? 'inherit' : 'hidden')

        this.svg.selectAll('.conjugate-zero')
          .data(data.filter(d => d.type === 'zero'))
          .join('g')
            .datum(d => ({...d, y: -d.y}))
            .classed('conjugate-zero', true)
            .attr('visibility', d => d.y == 0 ? 'hidden' : 'visible')
            // .classed('selected', (d, i) => i == this.selected)
            .call(drawZero)
            .call(this.drag)
            .attr('transform', d => `translate(${[this.x(d.x), this.y(-d.y)]})`)
            // .on('click', (d, i) => this.onSelect(d, i))
            .select('.strength')
              .text(d => d[2])
              .attr('visibility', d => d.strength > 1 ? 'inherit' : 'hidden')

        this.svg.selectAll('.pole')
          .data(data.filter(d => d.type === 'pole'))
          .join('g')
            .classed('pole', true)
            // .classed('selected', (d, i) => i == this.selected)
            .call(drawPole)
            .call(this.drag)
            .attr('transform', d => `translate(${[this.x(d.x), this.y(d.y)]})`)
            // .on('click', (d, i) => this.onSelect(d, i))
            .select('.strength')
              .text(d => d[2])
              .attr('visibility', d => d.strength > 1 ? 'inherit' : 'hidden')

        this.svg.selectAll('.conjugate-pole')
          .data(data.filter(d => d.type === 'pole'))
          .join('g')
            .datum(d => ({...d, y: -d.y}))
            .classed('conjugate-pole', true)
            // .classed('selected', (d, i) => i == this.selected)
            .call(drawPole)
            .call(this.drag)
            .attr('transform', d => `translate(${[this.x(d.x), this.y(d.y)]})`)
            // .on('click', (d, i) => this.onSelect(d, i))
            .select('.strength')
              .text(d => d[2])
              .attr('visibility', d => d.strength > 1 ? 'inherit' : 'hidden')
      }

      drawLayout() {
        this.svg.append('ellipse')
          .classed('unit-circle', true)
          .attr('cx', this.x(0))
          .attr('cy', this.y(0))
          .attr('rx', this.x(1) - this.x(0))
          .attr('ry', this.y(0) - this.y(1))

        this.svg.append('g')
          .classed('axis x-axis', true)
          .attr('transform', `translate(${[0, this.y(0)]})`)
          .call(d3.axisBottom(this.x).tickSize(0).tickValues([-1,1]))
          .append('text').text('Re')
            .attr('x', this.width)
            .attr('x', this.width - this.margin)
            .attr('dy', -6)

        this.svg.append('g')
          .classed('axis y-axis', true)
          .attr('transform', `translate(${[this.x(0), 0]})`)
          .call(d3.axisLeft(this.y).tickSize(0).tickValues([-1,1]))
          .append('text').text('Im')
            .attr('transform', 'rotate(-90)')
            .attr('x', -this.margin)
            .attr('y', 15)

        this.svg.selectAll('.axis .tick')
          .filter(d => d === 0 )
          .remove()
      }
    }

    class MagnitudePlot extends Plot {
      constructor(args) {
        super(args)
        this.drawLayout()
        this.y.clamp(true)
        this.magnitudePath = this.svg.append('path')
          .classed('magnitude', true)

        this.magnitudeArea = this.svg.append('path')
          .classed('magnitude-area', true)
      }

      drawLayout() {
        this.svg.append('g')
          .classed('axis x-axis', true)
          .attr('transform', `translate(${[0, this.height - this.margin]})`)
          .call(d3.axisBottom(this.x).tickSize(-this.height + 2 * this.margin).ticks(5))
          .append('text').text('Frequency')
            .attr('x', this.width/2)
            .attr('y', 25)

        this.svg.append('g')
          .classed('axis y-axis', true)
          .attr('transform', `translate(${[this.margin, 0]})`)
          .call(d3.axisLeft(this.y).tickSize(-this.width + 2 * this.margin).ticks(5))

        this.svg.selectAll('.tick').attr('stroke-dasharray', '1 2')
      }

      drawPath(data) {
        const line = d3.line()
          .x(d => this.x(d[0]))
          .y(d => this.y(d[1]))
        this.magnitudePath.attr('d', line(data))

        const area = d3.area()
          .x0(d => this.x(d[0]))
          .y1(d => this.y(d[1]))
          .y0(d => this.y.range()[1])

        this.magnitudeArea.attr('d', area(data))
      }
    }

    class PhasePlot extends Plot {
      constructor(args) {
        super(args)
        this.drawLayout()
        this.phasePath = this.svg.append('path').classed('phase', true)
      }

      drawPath(data) {
        const line = d3.line()
          .x(d => this.x(d[0]))
          .y(d => this.y(d[1]))
        this.phasePath.attr('d', line(data))
      }

      drawLayout() {
        this.svg.append('g')
          .classed('axis x-axis', true)
          .attr('transform', `translate(${[0, this.height - this.margin]})`)
          .call(d3.axisBottom(this.x).tickSize(-this.height + 2 * this.margin).ticks(5))
          .append('text').text('Frequency')
            .attr('x', this.width/2)
            .attr('y', 25)

        const labels = ['π', 'π/2', '0', '-π/2','-π']
        this.svg.append('g')
          .classed('axis y-axis', true)
          .attr('transform', `translate(${[this.margin, 0]})`)
          .call(d3.axisLeft(this.y)
          .tickSize(-this.width + 2 * this.margin)
          .tickValues(d3.range(Math.PI, -Math.PI-0.1, -Math.PI/2))
          .tickFormat((d,i) => labels[i]))

        this.svg.selectAll('.tick').attr('stroke-dasharray', '1 2')
      }
    }


    class TimePlot extends Plot {
      constructor(args) {
        super(args)
        this.drawLayout()
        this.createPaths()
        this.line = d3.line()
          .x(d => this.x(d[0]))
          .y(d => this.y(d[1]))
        createClippingRect(this.svg, 'clip', this.width, this.height)
      }

      createPaths() {
        this.sinePath = this.svg.append('path')
          .classed('sine', true)
          .attr('clip-path', 'url(#clip)')
        this.cosinePath = this.svg.append('path')
          .classed('cosine', true)
          .attr('clip-path', 'url(#clip)')
      }

      drawLayout() {
        this.svg.append('g')
          .classed('axis x-axis', true)
          .attr('transform', `translate(${[0, this.y(0)]})`)
          .call(d3.axisBottom(this.x).ticks(5).tickSize(0))
          .append('text').text('Time')
            .attr('x', this.width - this.margin)
            .attr('dy', -6)

        this.svg.append('g')
          .classed('axis y-axis', true)
          .attr('transform', `translate(${[this.x(0), 0]})`)
          .call(d3.axisLeft(this.y).ticks(5).tickSize(0))

        this.svg.selectAll('.x-axis .tick')
          .filter((d,i) => i === 0)
          .remove()
      }

      drawPath(data) {
        const max = d3.max(data, (d) => Math.max(Math.abs(d[1]), Math.abs(d[2])))
        this.y.domain([max, -max])
        this.svg.select('.y-axis').call(d3.axisLeft(this.y).ticks(5).tickSize(0))

        const cosine = data.map(d => [d[0], d[1]])
        const sine = data.map(d => [d[0], d[2]])
        this.sinePath.attr('d', this.line(sine))
        this.cosinePath.attr('d', this.line(cosine))
      }
    }

    const margin = 30
    const width = 400
    const height = 400

    const poleZero = new PoleZeroPlot({
      svgSelector:'#pole-zero',
      xdomain: [-1.5, 1.5],
      ydomain: [1.5, -1.5],
      width,
      height,
      margin,
      onDrag: (target) => {
        const i = data.findIndex(d => d.key === target.key)
        data[i] = target
        redraw()
      }
    })

    const magnitudePlot = new MagnitudePlot({
      svgSelector:'#magnitude',
      xdomain: [0, Math.PI],
      ydomain: [60, -60],
      width,
      height,
      margin,
    })

    const phasePlot = new PhasePlot({
      svgSelector:'#phase',
      xdomain: [0, Math.PI],
      ydomain: [3.5, -3.5],
      width,
      height,
      margin,
    })

    const timePlot = new TimePlot({
      svgSelector:'#timeplot',
      xdomain: [0, 50],
      ydomain: [2, -2],
      width: 800,
      height: 300,
      margin,
    })

    const time = d3.range(0, 50, 0.1)
    const frequencies = d3.range(0, Math.PI+0.01, 0.01)

    // const data = [
    //   zero( 0.0013674060635677, -0.9999990650998917, 1),
    //   zero(-0.7064224164410539, -0.7077904842180222, 1),
    //   pole( 0.3142251190555413, -0.6948674561628037, 1),
    //   pole( 0.1059132792803165, -0.2621513011445515, 1),
    // ]
    const data = [
      // zero(0, 0, 1),
      pole(0.85441, 0.23288, 1),
      pole(0.4, 0.7, 1)
      // zero(1, 0, 1),
      // pole(0.6, 0.75, 1),
      // pole(0.3, 0.8, 1),
      // zero(-0.3, 0.8, 1),
      // pole(0.5, 0, 1)
      // pole(1.2, 0.0, 1)
    ]
    const selected = -1

    poleZero.drawPolesZeros(data)

    const redraw = () => {
      const zeros = data.filter(d => d.type === 'zero')
      const poles = data.filter(d => d.type === 'pole')
      const magnitudeData = frequencies.map(f => magnitude(f, zeros, poles))
      const phaseData = frequencies.map(f => phase(f, zeros, poles))
      const timeData = time.map(t => [t, ...impulseResponse(t, zeros, poles, frequencies)])

      magnitudePlot.drawPath(magnitudeData)
      phasePlot.drawPath(phaseData)
      timePlot.drawPath(timeData)
    }

    redraw()

  </script>
</body>
</html>
